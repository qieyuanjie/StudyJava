# 类和对象
## 类的定义及使用
### 类的定义
类是构造对象的模板和蓝图
* 由类构造对象的过程称为"创建类的实例(instance)"
* 封装(亦称为数据隐藏),就是将数据和行为组合到一个包(package)中，并对对象的使用者隐藏具体的实现方式。
**封装是处理对象的一个重要概念。**
* 对象中的数据称为实例字段(instance field)
* 操作数据的方法称为方法(method)，C++中使用函数实现
* 状态(state)是当前对象的所有当前状态的集合
* 通过扩展一个类来建立另外一个新类的过程称为继承(inheritance),**值得注意的是继承一般会是一个更特殊的类继承一个更一般的类，同时会增加一些新的方法来处理所需的需求.**


### 对象
对象是包含对用户公开的特定功能部分和隐藏的实现部分的集合
* 每个对象都有三个主要特性
````
* 对象的行为（behavior）
* 对象的状态（state）
* 对象的标识（identity）
````
对应到Java中，分别是
````
行为 -> 可调用的方法 methods
状态 -> 描述当前状况的信息，比如各种变量
标识 -> 对象(或称对象实例)的名称
````
**要注意的的是对象的状态会随着时间而发生改变，这种改变不能是自发的，否则就破坏了封装性**


### 类的使用
Java中，使用构造器(constructor,或称构造函数)来构造对象实例。
* 构造器可以构造并初始化对象
* 构造器名字与类名相同，使用时在构造器前加上new操作符，如下：
```Java
new Date();
```
* 构造器构造出对象后，可以用一个对象变量来引用他，便于以后继续使用
```Java
Date birthday = new Date();

//继续使用
System.out.println(birthday);
```
* 对象变量(如birthday)不是对象，实际上若没有对其指定初始状态（即赋初值），其就没有引用任何对象，这时就不能对这个对象变量使用对象(Date)可使用的方法.
若要使用则必须先初始化，有两种初始化方法
```Java
deadline = new Date();

//让它引用一个已有对象
deadline = birthday;
```
* 可以显式的将对象变量设置为null表示其目前没有引用任何对象
```Java
deadline = null;
```
* 所有的Java对象都储存在堆上，当一个对象包含另外一个对象变量时，它只是包含了指向另外一个堆对象的指针。

### 静态工厂方法(factory method)
* 封装的意义就在于程序员不用考虑其内部的实例字段和具体方法实现，只需要考虑类对外提供的方法。
* 更改器方法和访问器方法
    * 更改器方法会修改对象的状态
    * 访问器方法只访问对象而不修改对象
### LocalDate类和Date类
```Java
//java.time.LocalDate;

//构造一个表示当前日期的对象
static LocalDate now()
//构造一个表现给定日期的对象，如1997-12-7
static LocalDate of(int year,int month,int day)
//得到当前日期的年月日
int getYear()
int getMonthValue()
int getDayofMonth()

//得到当前日期是星期几，作为DayOfWeek的一个对象实例返回，
//调用getValue来得到1-7之间的一个数，表示这是星期几
//1表示星期1,7表现星期日
DayOfWeek getDayOfWeek
//eg.
if(date.getDayOfWeek().getValue == 1){ System.out.println("今天星期1")}

//生成当前日期之后或者之前n天的日期
LocalDate plusDays(int n)//之后n天
LocalDate minusDays(int n)//之前n天

```
```Java
import java.time.*;

/**
 * @version 1.5 2015-05-08
 * @author Cay Horstmann
 * 这个示例展示了然后使用一个类的接口来完成相当复杂的任务如日历表，而不需要考虑具体实现，只需要使用import导入
 */
public class CalendarTest
{
   public static void main(String[] args)
   {
      LocalDate date = LocalDate.now();
      int month = date.getMonthValue();
      int today = date.getDayOfMonth();

      //假如今天4号，today=4,
      // 4-1=3,
      // date.minusDays(3)意思是今天之前3天的日期，即1号
      date = date.minusDays(today - 1); // set to start of month
      
      //得到这个月的第一天是星期几
      //今天4号，对应是星期日，
      // 这个月的第一天是星期4，即value=4
      DayOfWeek weekday = date.getDayOfWeek();
      int value = weekday.getValue(); // 1 = Monday, . . . , 7 = Sunday
      

      //打印日历中第一行的缩进，和表头
      System.out.println("Mon Tue Wed Thu Fri Sat Sun");
      for (int i = 1; i < value; i++)
         System.out.print("    ");
      
      //循环条件内设置，只打印当前月份的，到了下个月则循环结束
      //因为我们不知道这个月有几天，那就设置date还在当前月份就继续迭代打印
      while (date.getMonthValue() == month)
      {
         System.out.printf("%3d", date.getDayOfMonth());
         //如果打印到当前日期 如4号，则用一个*标记
         if (date.getDayOfMonth() == today)
            System.out.print("*");
         else
            System.out.print(" ");
         
         //日期加一天，并且当加到了下一个星期1时，自动换行
         date = date.plusDays(1);
         if (date.getDayOfWeek().getValue() == 1) System.out.println();
      }
      //循环体结束时，date应该是11月1日，星期日，所以要打印一个换行符结束
      //如果正好这天是星期1，之前的循环体最后已经打印过一个换行符，则不需要再次打印一个
      if (date.getDayOfWeek().getValue() != 1) System.out.println();
   }
}

```
### 多个源文件
* 可以任务Java的编译器内置了Unix或者Windows的make功能
* 多个源文件编译有两种命令格式.
其中第二钟方式没有显式地编译Employee.java,但当Java编译器发现EmployeeTest.java使用了Employee类时，他会自动查找Employee.class文件，
如果没找到，就会寻找Employee.java并对它进行编译
````
javac Employee*.java
//或者
javac EmployeeTest.java
````
### 构造器
* Java中的构造器总是要和new操作符一起使用，因为所有的Java对象都是在堆上构造的。初学者最容易犯的错误是忘记new操作符
### var,声明局部变量
* Java10中薪增了一个var关键字，用于声明局部变量，如果可以从变量的初始值直接推导出他们的类型，则无须在等号左侧指定类型，这种情况下可以使用var关键字
* 要注意的是对应基本数值类型，如int，long，double。最好不要滥用var关键字，建议少用或者不用，以此帮你你培养对数值精度的敏感性。
```Java
//例如
Employee harry = new Employee("Harry Hacker",50000,1989,10,1);
//可以写成以下代码
var harry = new Employee("Harry Hacker",50000,1989,10,1);

```
### 使用null 引用
### 类的访问权限
#### 私有方法
#### final实例字段
## 静态属性和方法
### 静态字段
如果将一个字段定义为static，这个字段就成为这个类所有对象共享访问的唯一标识码.<br>
静态字段也被成为类字段，“静态”是沿用了C++的叫法，无实际意义。

### 静态常量
静态常量经常使用，如Math类中定义了一个静态常量PI
```Java
public class Math{
...
public static final double PI = 3.14;
...
}
```
在程序中访问静态常量可以通过Math.PI访问
类似的System.out中也有静态常量即 System.out.PrintStream
#### 原生方法
即不是在Java语言中实现的方法，可以绕过Java的访问控制机制,实现修改final变量的值


### 静态方法
静态方法即不在对象上执行的方法，一般通过**类名.方法**的方式调用
```Java
Math.pow(x,a)
```
* 也可以使用对象来调用静态方法(例如用harr.getNextId()代替Employee.getNextId())，这是合法的。但这种写法容易造成阅读上的语义混淆，不建议这样写
下面两种情况下可以使用静态方法：
* 方法不需要访问对象状态，因为这个方法所需要的所有参赛都显式的通过传入的参数提供，如Math.pow()
* 方法只需要访问类的静态字段，如Employee.getNextId()
#### 工厂方法
静态方法的另外一种常见用途就是静态工厂方法(factory method)
```Java
LocalDate.now()
LocalDate.of()
```
下面给出常见的工厂方法的调用
```Java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
```
### 按值调用
Java总是按值调用的，即方法得到的所有参数值的一个副本，方法不能修改传递给他的任何参赛变量的内容，只是新建了一个副本，在这个副本基础上修改。方法结束时会调用gc，对副本进行销毁
* 但把对象引用作为参数时就不同了，由于传递到方法中的对象引用和原来的对象引用实际上是在指向同一个堆上的对象，所以就可以达到修改这个堆上对象的作用
### 方法参数总结
* 方法不能修改基本数据类型的参数(即数值型，布尔型等)
* 方法可以改变对象参数的状态。(通过对象引用)
* 方法不能让一个对象参数引用一个新的对象，(他们在方法内实现这些操作，但最后改变的只是对象引用的副本，并没有把改变的结果传递到方法外)
例如形参x、y交换了，实参a、b没有受到影响
见程序清单v1ch04p04-ParamTest/ParaTest.java
## 对象构造
### 重载
### 显式字段初始化
Java中提供了下面的写法对类中的实例字段进行初始化
```Java
class Empoyee{
    //注意这里
    private static int nextId;
    private int id = assignId();

    //...
    private static int assignId(){
        int r = nextId;
        nextId++;
        return r;
    }
}
```
* C++中不能直接初始化类的实例字段，所有的字段都必须放到构造器中设置，但C++也提供了一种特殊语法，称作"初始化器列表语法"来达成对类的实例字段进行初始化的目的。<br>
但Java中不需要这么麻烦，因为Java中的对象没有字对象，只有指向其他对象的指针，C++这么做是因为其类中可以有子对象，所以用这样的初始化方法来防止错误的语法,即对子对象进行初始化
### finalize
* 不要使用finalize方法来完成清理，这个方法已经被废弃。
* 可以改用close方法或者Runtime.addShutdownHook等方法。
* Java9以后可以使用Cleaner类来注册一个动作。
## 继承
* Java中，所有的继承都是公共继承(public)，没有C++中的保护和私有继承
* 超类和子类,分别对应其他程序设计语言中的双亲类和孩子类<br>
超super和子sub来自于计算机科学与数学理论中的集合语言的术语。<br>
所有员工组成的集合包含所有经理组成的集合。<br>
即员工集合是经理集合的超集，反过来说，经理集合是员工集合的子集
* 设计类的时候，应当将最一般的方法放在超类中，而将更特殊的方法放到子类
### 子类构造器
* 子类构造器中调用超类的构造器，这条语句一定要写在子类构造器中的第一行
```Java
pubulic Manager(String name,double salary,int year,int month,int day){
    //注意
    super(name,salary,year,month,day);
    bonus = 0;
}
```
类似与C++中在初始化列表中对超类进行构造
```C++
//C++
Manager::Manger(String name,double salary,int year,int month,int day)
:Employee(name,salary,year,month,day)
{
    bonus = 0;
}
```
### 多态、动态绑定、虚拟(virtual)、final
对于下面代码
```Java
     // construct a Manager object
            var boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
            boss.setBonus(5000);
    
            var staff = new Employee[3];
    
            // fill the staff array with Manager and Employee objects
    
            staff[0] = boss;
            staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
            staff[2] = new Employee("Tommy Tester", 40000, 1990, 3, 15);
    
            // print out information about all Employee objects
            for (Employee e : staff)
                System.out.println("name=" + e.getName() + ",salary=" + e.getSalary());
```
## 多态的含义
这里的e虽然声明为Employee类型，但当e引用staff[1]/staff[2]时，它可以引用Employee类型的对象，当e引用staff[0]时，也可以引用Manger类型的对象。<br>
* 一个对象变量(如e)可以指示多种实际类型的现象称为多态
* 在运行时可以自动地选择适当的方法，称为动态绑定
* C++中，要实现动态绑定，需要将成员函数(方法)声明为virtual
* 而在Java中默认是动态绑定的。如果不想让一个方法动态绑定(即虚拟的),则要单独把他标记为final

```Java
//这种调用是可以的
boss.setBonus(5000);
//而这种调用是不行的
staff[0].setBonus(5000);
```
这个例子中，虽然staff[0]和boss引用同一个对象，但上面那种调用可以，下面那种调用却不行。
这是因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。<br>
boss声明的类型是Manger。<br>
![](.1_基础知识._2_images/1360519b.png)

注意**对象引用**和**对象**的区别。staff[0]已经有了指向，我们说是对象，而e是对象引用，e既可以指向Employee,也可以指向Manager.
![](.1_基础知识._2_images/1fa49b97.png)


而且，不能将超类的引用赋给子类，例如，下面的赋值是非法的
```Java
Manager m = staff[i];
```
因为不是所有的员工都是经理，如果赋值成功，m就有可能引用了一个不是经理的Employee对象
### 多重继承
多重继承是一个子类可以有多个超类
Java不支持多重继承，但是提供了类似多重继承的功能，详情查看接口
* C++中，一个类可以有多个超类

## 包管理
### 包名
### 类的导入

## 枚举
## 反射
# 接口与抽象类
## 接口的定义及实现
## 抽象类的定义及实现
# 发布和部署
## JAR包概述
## 创建JAR包
## 引用JAR包